WHITESPACE = _{ " " | "\t" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }
end_line = _{ "\n"+ }
allow_end_line = _{ "\n"* }

program = { SOI ~ (stmt | end_line)* ~ EOI }
stmt = _{ (class_decl | assign_stmts | control_stmts | native_stmts | method_stmts | expr_stmt) ~ end_line }

// ASSIGN
assign_stmts = _{ assign_stmt | increment_stmt | decrement_stmt }

assign_stmt = { term ~ assign_operation ~ expr }
increment_stmt = { term ~ "++" }
decrement_stmt = { term ~ "--" }

assign_operation = _{ assign | assign_add | assign_subtract | assign_multiply | assign_divide }
    assign = { "=" }
    assign_add = { "+=" }
    assign_subtract = { "-=" }
    assign_multiply = { "*=" }
    assign_divide = { "/=" }


// CONTROL
control_stmts = _{ if_stmt | while_loop_stmt | for_loop_stmt | loop_until_stmt }

if_stmt = { "if" ~ expr ~ "then" ~ end_line
    ~ stmt*
    ~ elif_clause*
    ~ else_clause?
    ~ "end" ~ "if"
}
elif_clause = { "else" ~ "if" ~ expr ~ "then" ~ end_line
    ~ stmt*
}
else_clause = { "else" ~ end_line
    ~ stmt*
}

while_loop_stmt = { "loop" ~ "while" ~ expr ~ end_line
    ~ stmt*
    ~ (("end" ~ "loop") | ("end" ~ "while"))
}
for_loop_stmt = { "loop" ~ ident ~ "from" ~ expr ~ "to" ~ expr ~ end_line
    ~ stmt*
    ~ "end" ~ "loop"
}
loop_until_stmt = { "loop" ~ "until" ~ expr ~ end_line
    ~ stmt*
    ~ "end" ~ "loop"
}


// METHOD
method_stmts = _{ method_decl | method_return }

method_decl = {
    "method" ~ ident ~ decl_param_list ~ end_line
    ~ stmt*
    ~ "end" ~ "method"
}

method_call = { any_ident ~ call_param_list }
method_return = { "return" ~ expr }


// CLASS
class_decl = {
    static_keyword? ~ "Class" ~ ident ~ decl_param_list ~ end_line
    ~ (class_function | class_constructor_stmt)*
    ~ "end" ~ "Class"
}
class_new = { "new" ~ ident ~ call_param_list }

class_function = {
    class_ident ~ "=" ~ "function" ~ decl_param_list ~ allow_end_line
    ~ "{" ~ end_line
    ~ stmt*
    ~ "}" ~ end_line
}
class_constructor_stmt = { public_keyword? ~ class_ident ~ "=" ~ expr ~ end_line }
static_keyword = { "static" }
public_keyword = { "public" }

// EXPRESSION
expr_stmt = { term }
expr = { logical_or }

logical_or = { logical_and ~ (or ~ logical_and)* }
logical_and = { comparison ~ (and ~ comparison)* }

comparison = { add_sub ~ ( (not_equal | greater_equal | less_equal | greater | less | equal) ~ add_sub )* }
add_sub = { mul_div ~ ( (add | subtract) ~ mul_div )* }
mul_div = { pow ~ ( (multiply | divide | int_divide | modulo) ~ pow )* }
pow = { unary ~ (power ~ pow)? } // right-association
unary = { (not | subtract)* ~ term }
    equal = { "==" | "=" }
    not_equal = { "!=" | "<>" }
    greater_equal = { ">=" }
    less_equal = { "<=" }
    greater = { ">" }
    less = { "<" }
    add = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide = { "/" }
    int_divide = { "div" }
    power = { "^" }
    modulo = { "%" | "mod" }
    and = { "&&" | "AND" }
    or = { "||" | "OR" }
    not = { "!" | "NOT" }


// NATIVE METHODS
native_stmts = _{ input_stmt | output_stmt | assert_stmt }

input_stmt = { "input" ~ any_ident }
output_stmt = { "output" ~ expr ~ ("," ~ expr)* }
assert_stmt = { "assert" ~ "(" ~ expr ~ "," ~ expr ~ ")" }

// FUNDAMENTALS
decl_param_list = { "(" ~ (ident ~ ("," ~ ident)*)? ~ ")" }
call_param_list = { "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

term = { primary ~ postfix* }
primary = { number | string | bool | undefined | array | class_new | method_call | any_ident | "(" ~ expr ~ ")" }
postfix = { class_call | class_var | index }
class_var = { "." ~ ident }
class_call = { "." ~ ident ~ call_param_list }
index = { "[" ~ expr ~ "]" }

number = @{ int ~ ("." ~ ASCII_DIGIT*)? ~ ("e" ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
int = @{ ASCII_DIGIT+ }
string = @{ "\"" ~ ( "\\\"" | (!"\"" ~ ANY) )* ~ "\"" }
bool = { "true" | "false" }
undefined = { "undefined" }
array = { ("[" ~ allow_end_line ~ (expr ~ (allow_end_line ~ "," ~ allow_end_line ~ expr)*)? ~ allow_end_line ~ "]") | ("new" ~ "Array" ~ "()") }

ident = @{ !(reserved_keyword ~ !ASCII_ALPHANUMERIC) ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
class_ident = { "this" ~ "." ~ ident }
any_ident = _{ class_ident | ident }

reserved_keyword = { "Class"
         | "method"
         | "if"
         | "else"
         | "loop"
         | "while"
         | "for"
         | "until"
         | "end"
         | "return"
         | "output"
         | "assert"
         | "new"
         | "this"
         | "true"
         | "false"
         | "undefined"
         | static_keyword
         | public_keyword
         | "main"
}