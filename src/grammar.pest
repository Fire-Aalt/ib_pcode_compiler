WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* }

program = { SOI ~ stmt* ~ EOI }
stmt = _{ assign_stmts | control_stmts | output_stmt | assert_stmt | method_stmts }


// ASSIGN
assign_stmts = _{ assign_stmt | increment_stmt | decrement_stmt }

assign_stmt = { ident ~ assign_operation ~ expr }
increment_stmt = { ident ~ "++" }
decrement_stmt = { ident ~ "--" }

assign_operation = _{ assign | assign_add | assign_subtract | assign_multiply | assign_divide }
    assign = { "=" }
    assign_add = { "+=" }
    assign_subtract = { "-=" }
    assign_multiply = { "*=" }
    assign_divide = { "/=" }


// CONTROL
control_stmts = _{ if_stmt | while_loop_stmt | for_loop_stmt }

if_stmt = { "if" ~ expr ~ "then"
    ~ stmt*
    ~ "end if"
}
while_loop_stmt = { "loop" ~ "while" ~ expr
    ~ stmt*
    ~ "end loop"
}
for_loop_stmt = { "loop" ~ ident ~ "from" ~ expr ~ "to" ~ expr
    ~ stmt*
    ~ "end loop"
}


// METHOD
method_stmts = _{ method_decl | method_call | method_return }

method_decl = {
    "method" ~ method_ident ~  "(" ~ method_decl_param_list? ~ ")"
    ~ stmt*
    ~ "end" ~ "method"
}
method_decl_param_list = { ident ~ ("," ~ ident)* }

method_call = { method_ident ~ "(" ~ method_call_param_list? ~ ")" }
method_call_param_list = _{ expr ~ ("," ~ expr)* }

method_return = { "return" ~ expr }


// EXPRESSION
expr = { logical_or }

logical_or = _{ logical_and ~ (or ~ logical_and)* }
logical_and = _{ comparison ~ (and ~ comparison)* }

comparison = _{ add_sub ~ ( (greater_equal | less_equal | greater | less | equal | not_equal) ~ add_sub )* }
add_sub = _{ mul_div ~ ( (add | subtract) ~ mul_div )* }
mul_div = _{ pow ~ ( (multiply | divide | modulo) ~ pow )* }
pow = { unary ~ (power ~ pow)? } // right-association
unary = { (not | subtract)* ~ term }
    equal = { "==" | "=" }
    not_equal = { "!=" }
    greater_equal = { ">=" }
    less_equal = { "<=" }
    greater = { ">" }
    less = { "<" }
    add = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide = { "/" }
    power = { "^" }
    modulo = { "%" }
    and = { "&&" | "AND" }
    or = { "||" | "OR" }
    not = { "!" | "NOT" }


// NATIVE METHODS
input = { "input" ~ "(" ~ expr? ~ ")" }
output_stmt = { "output" ~ expr ~ ("," ~ expr)* }
assert_stmt = { "assert" ~ "(" ~ expr ~ "," ~ expr ~ ")" }

// FUNDAMENTALS
term = _{ input | method_call | ident | number | string | bool | "(" ~ expr ~ ")" }

ident = @{ ASCII_ALPHA_UPPER ~ (ASCII_DIGIT | ASCII_ALPHA_UPPER | "_")* }
method_ident = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
number = @{ int ~ ("." ~ ASCII_DIGIT*)? ~ ("e" ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
int = @{ ASCII_DIGIT+ }
string = @{ "\"" ~ ( "\\\"" | (!"\"" ~ ANY) )* ~ "\"" }
bool = { "true" | "false" }